<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ice Hockey 1v1 Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load GLTFLoader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/GLTFLoader.js"></script>
</head>
<body>
<script>
    let scene, camera, renderer;
    let player, opponent, puck;
    let playerSpeed = 0.1;
    let puckSpeed = { x: 0, z: 0 };
    let keys = {};
    let controlledPlayer = 0;

    let playerModel, mixer;

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create Ice Rink
        let rinkGeometry = new THREE.PlaneGeometry(50, 30);
        let rinkMaterial = new THREE.MeshBasicMaterial({ color: 0xADD8E6, side: THREE.DoubleSide });
        let rink = new THREE.Mesh(rinkGeometry, rinkMaterial);
        rink.rotation.x = -Math.PI / 2;
        scene.add(rink);

        // Create Puck
        createPuck();

        // Load Player Model
        loadPlayerModel();

        // Create Opponent (placeholder cube for now)
        createOpponent();

        camera.position.set(0, 20, 20);
        camera.lookAt(0, 0, 0);

        // Add Event Listeners for Controls
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        animate();
    }

    // Load the Player Model (hockey_player.glb)
    function loadPlayerModel() {
        let loader = new THREE.GLTFLoader();
        loader.load('hockey_player.glb', (gltf) => {
            playerModel = gltf.scene;
            playerModel.scale.set(1, 1, 1);
            playerModel.position.set(0, 0, 0);
            scene.add(playerModel);

            // Check for animations
            if (gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(playerModel);
                gltf.animations.forEach((clip) => {
                    mixer.clipAction(clip).play();
                });
            }
        });
    }

    // Create the Puck
    function createPuck() {
        let puckGeometry = new THREE.CircleGeometry(0.5, 32);
        let puckMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        puck = new THREE.Mesh(puckGeometry, puckMaterial);
        puck.position.set(0, 0.1, 0);
        scene.add(puck);
    }

    // Create Opponent (simple placeholder cube for now)
    function createOpponent() {
        let opponentGeometry = new THREE.BoxGeometry(1, 2, 1);
        let opponentMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
        opponent = new THREE.Mesh(opponentGeometry, opponentMaterial);
        opponent.position.set(5, 1, 0);
        scene.add(opponent);
    }

    // Handle Player Movement
    function handlePlayerMovement() {
        if (!playerModel) return; // Wait for player model to load

        let speed = playerSpeed;
        let playerPosition = playerModel.position;

        if (keys['w']) playerPosition.z -= speed;
        if (keys['s']) playerPosition.z += speed;
        if (keys['a']) playerPosition.x -= speed;
        if (keys['d']) playerPosition.x += speed;

        // Apply skating animation (if available)
        if (mixer) {
            mixer.update(0.01); // Update animation mixer
        }
    }

    // Update the Game Scene
    function animate() {
        requestAnimationFrame(animate);

        handlePlayerMovement();
        updatePuck();

        renderer.render(scene, camera);
    }

    // Update the puck position
    function updatePuck() {
        puck.position.x += puckSpeed.x;
        puck.position.z += puckSpeed.z;

        // Bounce off walls
        if (puck.position.x < -25 || puck.position.x > 25) puckSpeed.x *= -1;
        if (puck.position.z < -15 || puck.position.z > 15) puckSpeed.z *= -1;
    }

    init();
</script>
</body>
</html>
